// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Command.proto

#ifndef PROTOBUF_Command_2eproto__INCLUDED
#define PROTOBUF_Command_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "GameDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace Cmd {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Command_2eproto();
void protobuf_AssignDesc_Command_2eproto();
void protobuf_ShutdownFile_Command_2eproto();

class GameRole;
class ItemObject;
class RTMainUser;
class ReqAccountOperation;
class ReqChat;
class ReqCreateRole;
class ReqLoginGameServer;
class ReqUseObject;
class RetAccountOperation;
class RetCreateRole;
class RetLoginGameServer;
class RetMessage;
class RetObjectAdd;
class RetObjectDelete;
class RetObjectMove;
class RetObjectSync;
class RetTimeLine;

enum AccountAction {
  AccountAction_None = 0,
  AccountAction_Create = 1,
  AccountAction_Rename = 2,
  AccountAction_Delete = 3,
  AccountAction_Login = 4
};
bool AccountAction_IsValid(int value);
const AccountAction AccountAction_MIN = AccountAction_None;
const AccountAction AccountAction_MAX = AccountAction_Login;
const int AccountAction_ARRAYSIZE = AccountAction_MAX + 1;

enum AccountErrorCode {
  AccountErrorCode_None = 0,
  AccountErrorCode_CreateSucessed = 1,
  AccountErrorCode_NameRepeated = 2,
  AccountErrorCode_UserCantFind = 3,
  AccountErrorCode_PasswordError = 4,
  AccountErrorCode_LoginSucessed = 5
};
bool AccountErrorCode_IsValid(int value);
const AccountErrorCode AccountErrorCode_MIN = AccountErrorCode_None;
const AccountErrorCode AccountErrorCode_MAX = AccountErrorCode_LoginSucessed;
const int AccountErrorCode_ARRAYSIZE = AccountErrorCode_MAX + 1;

enum LoginGameError {
  LoginGameSucess = 100,
  LoginGameOverdue = 300,
  LoginGameInvalid = 400
};
bool LoginGameError_IsValid(int value);
const LoginGameError LoginGameError_MIN = LoginGameSucess;
const LoginGameError LoginGameError_MAX = LoginGameInvalid;
const int LoginGameError_ARRAYSIZE = LoginGameError_MAX + 1;

enum CreateRoleError {
  CreateRoleSucess = 0,
  CreateRoleNameRepeated = 1
};
bool CreateRoleError_IsValid(int value);
const CreateRoleError CreateRoleError_MIN = CreateRoleSucess;
const CreateRoleError CreateRoleError_MAX = CreateRoleNameRepeated;
const int CreateRoleError_ARRAYSIZE = CreateRoleError_MAX + 1;

enum MessageSender {
  MessageSender_System = 0,
  MessageSender_User = 1
};
bool MessageSender_IsValid(int value);
const MessageSender MessageSender_MIN = MessageSender_System;
const MessageSender MessageSender_MAX = MessageSender_User;
const int MessageSender_ARRAYSIZE = MessageSender_MAX + 1;

enum MessageChannel {
  MessageChannel_System_None = 0,
  MessageChannel_System_Error = 1,
  MessageChannel_System_Sucess = 2,
  MessageChannel_System_TV = 3,
  MessageChannel_System_MessageBox = 4,
  MessageChannel_System_Count = 5,
  MessageChannel_User_None = 10,
  MessageChannel_User_Normal = 11,
  MessageChannel_User_World = 12,
  MessageChannel_User_Louder = 13,
  MessageChannel_User_Count = 14
};
bool MessageChannel_IsValid(int value);
const MessageChannel MessageChannel_MIN = MessageChannel_System_None;
const MessageChannel MessageChannel_MAX = MessageChannel_User_Count;
const int MessageChannel_ARRAYSIZE = MessageChannel_MAX + 1;

// ===================================================================

class ReqAccountOperation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqAccountOperation) */ {
 public:
  ReqAccountOperation();
  virtual ~ReqAccountOperation();

  ReqAccountOperation(const ReqAccountOperation& from);

  inline ReqAccountOperation& operator=(const ReqAccountOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqAccountOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqAccountOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqAccountOperation* other);

  // implements Message ----------------------------------------------

  inline ReqAccountOperation* New() const { return New(NULL); }

  ReqAccountOperation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqAccountOperation& from);
  void MergeFrom(const ReqAccountOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqAccountOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Cmd.AccountAction action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::Cmd::AccountAction action() const;
  void set_action(::Cmd::AccountAction value);

  // required string user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Cmd.ReqAccountOperation)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  int action_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqAccountOperation* default_instance_;
};
// -------------------------------------------------------------------

class RetAccountOperation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetAccountOperation) */ {
 public:
  RetAccountOperation();
  virtual ~RetAccountOperation();

  RetAccountOperation(const RetAccountOperation& from);

  inline RetAccountOperation& operator=(const RetAccountOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetAccountOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetAccountOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetAccountOperation* other);

  // implements Message ----------------------------------------------

  inline RetAccountOperation* New() const { return New(NULL); }

  RetAccountOperation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetAccountOperation& from);
  void MergeFrom(const RetAccountOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetAccountOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Cmd.AccountErrorCode error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Cmd::AccountErrorCode error() const;
  void set_error(::Cmd::AccountErrorCode value);

  // required int32 accountid = 2;
  bool has_accountid() const;
  void clear_accountid();
  static const int kAccountidFieldNumber = 2;
  ::google::protobuf::int32 accountid() const;
  void set_accountid(::google::protobuf::int32 value);

  // required int32 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // required string token = 4;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // repeated int32 late_serverids = 5;
  int late_serverids_size() const;
  void clear_late_serverids();
  static const int kLateServeridsFieldNumber = 5;
  ::google::protobuf::int32 late_serverids(int index) const;
  void set_late_serverids(int index, ::google::protobuf::int32 value);
  void add_late_serverids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      late_serverids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_late_serverids();

  // @@protoc_insertion_point(class_scope:Cmd.RetAccountOperation)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int error_;
  ::google::protobuf::int32 accountid_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > late_serverids_;
  ::google::protobuf::int32 time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetAccountOperation* default_instance_;
};
// -------------------------------------------------------------------

class ReqLoginGameServer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqLoginGameServer) */ {
 public:
  ReqLoginGameServer();
  virtual ~ReqLoginGameServer();

  ReqLoginGameServer(const ReqLoginGameServer& from);

  inline ReqLoginGameServer& operator=(const ReqLoginGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqLoginGameServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqLoginGameServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqLoginGameServer* other);

  // implements Message ----------------------------------------------

  inline ReqLoginGameServer* New() const { return New(NULL); }

  ReqLoginGameServer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqLoginGameServer& from);
  void MergeFrom(const ReqLoginGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqLoginGameServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 accountid = 1;
  bool has_accountid() const;
  void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  ::google::protobuf::int32 accountid() const;
  void set_accountid(::google::protobuf::int32 value);

  // required int32 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // required string token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Cmd.ReqLoginGameServer)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 accountid_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqLoginGameServer* default_instance_;
};
// -------------------------------------------------------------------

class GameRole : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.GameRole) */ {
 public:
  GameRole();
  virtual ~GameRole();

  GameRole(const GameRole& from);

  inline GameRole& operator=(const GameRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GameRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameRole* other);

  // implements Message ----------------------------------------------

  inline GameRole* New() const { return New(NULL); }

  GameRole* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameRole& from);
  void MergeFrom(const GameRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 sex = 4;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 4;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // optional int32 job = 5;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 5;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // optional int32 vip = 6;
  bool has_vip() const;
  void clear_vip();
  static const int kVipFieldNumber = 6;
  ::google::protobuf::int32 vip() const;
  void set_vip(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.GameRole)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_vip();
  inline void clear_has_vip();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 vip_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static GameRole* default_instance_;
};
// -------------------------------------------------------------------

class RetLoginGameServer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetLoginGameServer) */ {
 public:
  RetLoginGameServer();
  virtual ~RetLoginGameServer();

  RetLoginGameServer(const RetLoginGameServer& from);

  inline RetLoginGameServer& operator=(const RetLoginGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetLoginGameServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetLoginGameServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetLoginGameServer* other);

  // implements Message ----------------------------------------------

  inline RetLoginGameServer* New() const { return New(NULL); }

  RetLoginGameServer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetLoginGameServer& from);
  void MergeFrom(const RetLoginGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetLoginGameServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Cmd.LoginGameError error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Cmd::LoginGameError error() const;
  void set_error(::Cmd::LoginGameError value);

  // required .Cmd.GameRole role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::Cmd::GameRole& role() const;
  ::Cmd::GameRole* mutable_role();
  ::Cmd::GameRole* release_role();
  void set_allocated_role(::Cmd::GameRole* role);

  // @@protoc_insertion_point(class_scope:Cmd.RetLoginGameServer)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_role();
  inline void clear_has_role();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Cmd::GameRole* role_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetLoginGameServer* default_instance_;
};
// -------------------------------------------------------------------

class ReqCreateRole : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqCreateRole) */ {
 public:
  ReqCreateRole();
  virtual ~ReqCreateRole();

  ReqCreateRole(const ReqCreateRole& from);

  inline ReqCreateRole& operator=(const ReqCreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqCreateRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqCreateRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqCreateRole* other);

  // implements Message ----------------------------------------------

  inline ReqCreateRole* New() const { return New(NULL); }

  ReqCreateRole* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqCreateRole& from);
  void MergeFrom(const ReqCreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqCreateRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sex = 1;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 1;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // optional int32 job = 2;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 2;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Cmd.ReqCreateRole)
 private:
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqCreateRole* default_instance_;
};
// -------------------------------------------------------------------

class RetCreateRole : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetCreateRole) */ {
 public:
  RetCreateRole();
  virtual ~RetCreateRole();

  RetCreateRole(const RetCreateRole& from);

  inline RetCreateRole& operator=(const RetCreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetCreateRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetCreateRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetCreateRole* other);

  // implements Message ----------------------------------------------

  inline RetCreateRole* New() const { return New(NULL); }

  RetCreateRole* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetCreateRole& from);
  void MergeFrom(const RetCreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetCreateRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.CreateRoleError error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Cmd::CreateRoleError error() const;
  void set_error(::Cmd::CreateRoleError value);

  // optional .Cmd.GameRole role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::Cmd::GameRole& role() const;
  ::Cmd::GameRole* mutable_role();
  ::Cmd::GameRole* release_role();
  void set_allocated_role(::Cmd::GameRole* role);

  // @@protoc_insertion_point(class_scope:Cmd.RetCreateRole)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Cmd::GameRole* role_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetCreateRole* default_instance_;
};
// -------------------------------------------------------------------

class RTMainUser : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RTMainUser) */ {
 public:
  RTMainUser();
  virtual ~RTMainUser();

  RTMainUser(const RTMainUser& from);

  inline RTMainUser& operator=(const RTMainUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RTMainUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RTMainUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RTMainUser* other);

  // implements Message ----------------------------------------------

  inline RTMainUser* New() const { return New(NULL); }

  RTMainUser* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RTMainUser& from);
  void MergeFrom(const RTMainUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RTMainUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charID = 1;
  bool has_charid() const;
  void clear_charid();
  static const int kCharIDFieldNumber = 1;
  ::google::protobuf::int32 charid() const;
  void set_charid(::google::protobuf::int32 value);

  // optional int32 job = 2;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 2;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // optional int32 sex = 3;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 3;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 vip = 5;
  bool has_vip() const;
  void clear_vip();
  static const int kVipFieldNumber = 5;
  ::google::protobuf::int32 vip() const;
  void set_vip(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.RTMainUser)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_vip();
  inline void clear_has_vip();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 vip_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RTMainUser* default_instance_;
};
// -------------------------------------------------------------------

class RetTimeLine : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetTimeLine) */ {
 public:
  RetTimeLine();
  virtual ~RetTimeLine();

  RetTimeLine(const RetTimeLine& from);

  inline RetTimeLine& operator=(const RetTimeLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetTimeLine& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetTimeLine* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetTimeLine* other);

  // implements Message ----------------------------------------------

  inline RetTimeLine* New() const { return New(NULL); }

  RetTimeLine* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetTimeLine& from);
  void MergeFrom(const RetTimeLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetTimeLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 trun = 1;
  bool has_trun() const;
  void clear_trun();
  static const int kTrunFieldNumber = 1;
  ::google::protobuf::int32 trun() const;
  void set_trun(::google::protobuf::int32 value);

  // optional int32 leftSeconds = 2;
  bool has_leftseconds() const;
  void clear_leftseconds();
  static const int kLeftSecondsFieldNumber = 2;
  ::google::protobuf::int32 leftseconds() const;
  void set_leftseconds(::google::protobuf::int32 value);

  // optional int32 totalSeconds = 3;
  bool has_totalseconds() const;
  void clear_totalseconds();
  static const int kTotalSecondsFieldNumber = 3;
  ::google::protobuf::int32 totalseconds() const;
  void set_totalseconds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.RetTimeLine)
 private:
  inline void set_has_trun();
  inline void clear_has_trun();
  inline void set_has_leftseconds();
  inline void clear_has_leftseconds();
  inline void set_has_totalseconds();
  inline void clear_has_totalseconds();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 trun_;
  ::google::protobuf::int32 leftseconds_;
  ::google::protobuf::int32 totalseconds_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetTimeLine* default_instance_;
};
// -------------------------------------------------------------------

class ItemObject : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ItemObject) */ {
 public:
  ItemObject();
  virtual ~ItemObject();

  ItemObject(const ItemObject& from);

  inline ItemObject& operator=(const ItemObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ItemObject& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemObject* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemObject* other);

  // implements Message ----------------------------------------------

  inline ItemObject* New() const { return New(NULL); }

  ItemObject* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemObject& from);
  void MergeFrom(const ItemObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ItemObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 dbID = 1;
  bool has_dbid() const;
  void clear_dbid();
  static const int kDbIDFieldNumber = 1;
  ::google::protobuf::int32 dbid() const;
  void set_dbid(::google::protobuf::int32 value);

  // optional int32 itemid = 2;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemidFieldNumber = 2;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // optional int32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // optional .GameDefine.ObjectCellType cell = 4 [default = ObjectCellType_None];
  bool has_cell() const;
  void clear_cell();
  static const int kCellFieldNumber = 4;
  ::GameDefine::ObjectCellType cell() const;
  void set_cell(::GameDefine::ObjectCellType value);

  // optional int32 position = 5;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 5;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.ItemObject)
 private:
  inline void set_has_dbid();
  inline void clear_has_dbid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_cell();
  inline void clear_has_cell();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 dbid_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  int cell_;
  ::google::protobuf::int32 position_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ItemObject* default_instance_;
};
// -------------------------------------------------------------------

class RetObjectAdd : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetObjectAdd) */ {
 public:
  RetObjectAdd();
  virtual ~RetObjectAdd();

  RetObjectAdd(const RetObjectAdd& from);

  inline RetObjectAdd& operator=(const RetObjectAdd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetObjectAdd& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetObjectAdd* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetObjectAdd* other);

  // implements Message ----------------------------------------------

  inline RetObjectAdd* New() const { return New(NULL); }

  RetObjectAdd* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetObjectAdd& from);
  void MergeFrom(const RetObjectAdd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetObjectAdd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.ItemObject objects = 1;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 1;
  const ::Cmd::ItemObject& objects(int index) const;
  ::Cmd::ItemObject* mutable_objects(int index);
  ::Cmd::ItemObject* add_objects();
  ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >*
      mutable_objects();
  const ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Cmd.RetObjectAdd)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject > objects_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetObjectAdd* default_instance_;
};
// -------------------------------------------------------------------

class RetObjectSync : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetObjectSync) */ {
 public:
  RetObjectSync();
  virtual ~RetObjectSync();

  RetObjectSync(const RetObjectSync& from);

  inline RetObjectSync& operator=(const RetObjectSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetObjectSync& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetObjectSync* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetObjectSync* other);

  // implements Message ----------------------------------------------

  inline RetObjectSync* New() const { return New(NULL); }

  RetObjectSync* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetObjectSync& from);
  void MergeFrom(const RetObjectSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetObjectSync* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.ItemObject objects = 1;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 1;
  const ::Cmd::ItemObject& objects(int index) const;
  ::Cmd::ItemObject* mutable_objects(int index);
  ::Cmd::ItemObject* add_objects();
  ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >*
      mutable_objects();
  const ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Cmd.RetObjectSync)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject > objects_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetObjectSync* default_instance_;
};
// -------------------------------------------------------------------

class RetObjectDelete : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetObjectDelete) */ {
 public:
  RetObjectDelete();
  virtual ~RetObjectDelete();

  RetObjectDelete(const RetObjectDelete& from);

  inline RetObjectDelete& operator=(const RetObjectDelete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetObjectDelete& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetObjectDelete* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetObjectDelete* other);

  // implements Message ----------------------------------------------

  inline RetObjectDelete* New() const { return New(NULL); }

  RetObjectDelete* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetObjectDelete& from);
  void MergeFrom(const RetObjectDelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetObjectDelete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 objects = 1;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 1;
  ::google::protobuf::int32 objects(int index) const;
  void set_objects(int index, ::google::protobuf::int32 value);
  void add_objects(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      objects() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_objects();

  // @@protoc_insertion_point(class_scope:Cmd.RetObjectDelete)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > objects_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetObjectDelete* default_instance_;
};
// -------------------------------------------------------------------

class RetObjectMove : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetObjectMove) */ {
 public:
  RetObjectMove();
  virtual ~RetObjectMove();

  RetObjectMove(const RetObjectMove& from);

  inline RetObjectMove& operator=(const RetObjectMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetObjectMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetObjectMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetObjectMove* other);

  // implements Message ----------------------------------------------

  inline RetObjectMove* New() const { return New(NULL); }

  RetObjectMove* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetObjectMove& from);
  void MergeFrom(const RetObjectMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetObjectMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 dbID = 1;
  bool has_dbid() const;
  void clear_dbid();
  static const int kDbIDFieldNumber = 1;
  ::google::protobuf::int32 dbid() const;
  void set_dbid(::google::protobuf::int32 value);

  // optional .GameDefine.ObjectCellType cell = 2 [default = ObjectCellType_None];
  bool has_cell() const;
  void clear_cell();
  static const int kCellFieldNumber = 2;
  ::GameDefine::ObjectCellType cell() const;
  void set_cell(::GameDefine::ObjectCellType value);

  // optional int32 position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.RetObjectMove)
 private:
  inline void set_has_dbid();
  inline void clear_has_dbid();
  inline void set_has_cell();
  inline void clear_has_cell();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 dbid_;
  int cell_;
  ::google::protobuf::int32 position_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetObjectMove* default_instance_;
};
// -------------------------------------------------------------------

class ReqUseObject : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqUseObject) */ {
 public:
  ReqUseObject();
  virtual ~ReqUseObject();

  ReqUseObject(const ReqUseObject& from);

  inline ReqUseObject& operator=(const ReqUseObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqUseObject& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqUseObject* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqUseObject* other);

  // implements Message ----------------------------------------------

  inline ReqUseObject* New() const { return New(NULL); }

  ReqUseObject* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqUseObject& from);
  void MergeFrom(const ReqUseObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqUseObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 dbID = 1;
  bool has_dbid() const;
  void clear_dbid();
  static const int kDbIDFieldNumber = 1;
  ::google::protobuf::int32 dbid() const;
  void set_dbid(::google::protobuf::int32 value);

  // optional int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.ReqUseObject)
 private:
  inline void set_has_dbid();
  inline void clear_has_dbid();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 dbid_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqUseObject* default_instance_;
};
// -------------------------------------------------------------------

class RetMessage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetMessage) */ {
 public:
  RetMessage();
  virtual ~RetMessage();

  RetMessage(const RetMessage& from);

  inline RetMessage& operator=(const RetMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetMessage* other);

  // implements Message ----------------------------------------------

  inline RetMessage* New() const { return New(NULL); }

  RetMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetMessage& from);
  void MergeFrom(const RetMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.MessageChannel channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::Cmd::MessageChannel channel() const;
  void set_channel(::Cmd::MessageChannel value);

  // optional string sender = 2;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 2;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // optional string content = 3;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional int32 localTime = 4;
  bool has_localtime() const;
  void clear_localtime();
  static const int kLocalTimeFieldNumber = 4;
  ::google::protobuf::int32 localtime() const;
  void set_localtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.RetMessage)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_localtime();
  inline void clear_has_localtime();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  int channel_;
  ::google::protobuf::int32 localtime_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReqChat : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqChat) */ {
 public:
  ReqChat();
  virtual ~ReqChat();

  ReqChat(const ReqChat& from);

  inline ReqChat& operator=(const ReqChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqChat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqChat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqChat* other);

  // implements Message ----------------------------------------------

  inline ReqChat* New() const { return New(NULL); }

  ReqChat* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqChat& from);
  void MergeFrom(const ReqChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.MessageChannel channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::Cmd::MessageChannel channel() const;
  void set_channel(::Cmd::MessageChannel value);

  // optional int32 roleID = 2;
  bool has_roleid() const;
  void clear_roleid();
  static const int kRoleIDFieldNumber = 2;
  ::google::protobuf::int32 roleid() const;
  void set_roleid(::google::protobuf::int32 value);

  // optional string from = 3;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 3;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // optional string to = 4;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 4;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional string content = 5;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 5;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Cmd.ReqChat)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int channel_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqChat* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ReqAccountOperation

// required .Cmd.AccountAction action = 1;
inline bool ReqAccountOperation::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAccountOperation::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAccountOperation::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAccountOperation::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::Cmd::AccountAction ReqAccountOperation::action() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqAccountOperation.action)
  return static_cast< ::Cmd::AccountAction >(action_);
}
inline void ReqAccountOperation::set_action(::Cmd::AccountAction value) {
  assert(::Cmd::AccountAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqAccountOperation.action)
}

// required string user = 2;
inline bool ReqAccountOperation::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAccountOperation::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAccountOperation::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAccountOperation::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ReqAccountOperation::user() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqAccountOperation.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqAccountOperation.user)
}
inline void ReqAccountOperation::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqAccountOperation.user)
}
inline void ReqAccountOperation::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqAccountOperation.user)
}
inline ::std::string* ReqAccountOperation::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqAccountOperation.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqAccountOperation::release_user() {
  // @@protoc_insertion_point(field_release:Cmd.ReqAccountOperation.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqAccountOperation.user)
}

// required string password = 3;
inline bool ReqAccountOperation::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAccountOperation::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAccountOperation::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAccountOperation::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& ReqAccountOperation::password() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqAccountOperation.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqAccountOperation.password)
}
inline void ReqAccountOperation::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqAccountOperation.password)
}
inline void ReqAccountOperation::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqAccountOperation.password)
}
inline ::std::string* ReqAccountOperation::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqAccountOperation.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqAccountOperation::release_password() {
  // @@protoc_insertion_point(field_release:Cmd.ReqAccountOperation.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqAccountOperation.password)
}

// -------------------------------------------------------------------

// RetAccountOperation

// required .Cmd.AccountErrorCode error = 1;
inline bool RetAccountOperation::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetAccountOperation::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetAccountOperation::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetAccountOperation::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::Cmd::AccountErrorCode RetAccountOperation::error() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.error)
  return static_cast< ::Cmd::AccountErrorCode >(error_);
}
inline void RetAccountOperation::set_error(::Cmd::AccountErrorCode value) {
  assert(::Cmd::AccountErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.error)
}

// required int32 accountid = 2;
inline bool RetAccountOperation::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetAccountOperation::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetAccountOperation::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetAccountOperation::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 RetAccountOperation::accountid() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.accountid)
  return accountid_;
}
inline void RetAccountOperation::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.accountid)
}

// required int32 time = 3;
inline bool RetAccountOperation::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetAccountOperation::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetAccountOperation::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetAccountOperation::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 RetAccountOperation::time() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.time)
  return time_;
}
inline void RetAccountOperation::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.time)
}

// required string token = 4;
inline bool RetAccountOperation::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetAccountOperation::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetAccountOperation::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetAccountOperation::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& RetAccountOperation::token() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetAccountOperation::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.token)
}
inline void RetAccountOperation::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.RetAccountOperation.token)
}
inline void RetAccountOperation::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.RetAccountOperation.token)
}
inline ::std::string* RetAccountOperation::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:Cmd.RetAccountOperation.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RetAccountOperation::release_token() {
  // @@protoc_insertion_point(field_release:Cmd.RetAccountOperation.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetAccountOperation::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetAccountOperation.token)
}

// repeated int32 late_serverids = 5;
inline int RetAccountOperation::late_serverids_size() const {
  return late_serverids_.size();
}
inline void RetAccountOperation::clear_late_serverids() {
  late_serverids_.Clear();
}
inline ::google::protobuf::int32 RetAccountOperation::late_serverids(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.late_serverids)
  return late_serverids_.Get(index);
}
inline void RetAccountOperation::set_late_serverids(int index, ::google::protobuf::int32 value) {
  late_serverids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.late_serverids)
}
inline void RetAccountOperation::add_late_serverids(::google::protobuf::int32 value) {
  late_serverids_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.RetAccountOperation.late_serverids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RetAccountOperation::late_serverids() const {
  // @@protoc_insertion_point(field_list:Cmd.RetAccountOperation.late_serverids)
  return late_serverids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RetAccountOperation::mutable_late_serverids() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.RetAccountOperation.late_serverids)
  return &late_serverids_;
}

// -------------------------------------------------------------------

// ReqLoginGameServer

// required int32 accountid = 1;
inline bool ReqLoginGameServer::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLoginGameServer::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLoginGameServer::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLoginGameServer::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 ReqLoginGameServer::accountid() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqLoginGameServer.accountid)
  return accountid_;
}
inline void ReqLoginGameServer::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqLoginGameServer.accountid)
}

// required int32 time = 2;
inline bool ReqLoginGameServer::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLoginGameServer::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLoginGameServer::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLoginGameServer::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 ReqLoginGameServer::time() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqLoginGameServer.time)
  return time_;
}
inline void ReqLoginGameServer::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqLoginGameServer.time)
}

// required string token = 3;
inline bool ReqLoginGameServer::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLoginGameServer::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLoginGameServer::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLoginGameServer::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& ReqLoginGameServer::token() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqLoginGameServer.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLoginGameServer::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqLoginGameServer.token)
}
inline void ReqLoginGameServer::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqLoginGameServer.token)
}
inline void ReqLoginGameServer::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqLoginGameServer.token)
}
inline ::std::string* ReqLoginGameServer::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqLoginGameServer.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLoginGameServer::release_token() {
  // @@protoc_insertion_point(field_release:Cmd.ReqLoginGameServer.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLoginGameServer::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqLoginGameServer.token)
}

// -------------------------------------------------------------------

// GameRole

// required int32 id = 1;
inline bool GameRole::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRole::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRole::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRole::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameRole::id() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.id)
  return id_;
}
inline void GameRole::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.id)
}

// optional int32 level = 2;
inline bool GameRole::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRole::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRole::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRole::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GameRole::level() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.level)
  return level_;
}
inline void GameRole::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.level)
}

// optional string name = 3;
inline bool GameRole::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameRole::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameRole::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GameRole::name() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRole::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.GameRole.name)
}
inline void GameRole::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.GameRole.name)
}
inline void GameRole::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.GameRole.name)
}
inline ::std::string* GameRole::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Cmd.GameRole.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameRole::release_name() {
  // @@protoc_insertion_point(field_release:Cmd.GameRole.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRole::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Cmd.GameRole.name)
}

// optional int32 sex = 4;
inline bool GameRole::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameRole::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameRole::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameRole::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 GameRole::sex() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.sex)
  return sex_;
}
inline void GameRole::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.sex)
}

// optional int32 job = 5;
inline bool GameRole::has_job() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameRole::set_has_job() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameRole::clear_has_job() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameRole::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 GameRole::job() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.job)
  return job_;
}
inline void GameRole::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.job)
}

// optional int32 vip = 6;
inline bool GameRole::has_vip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameRole::set_has_vip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameRole::clear_has_vip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameRole::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 GameRole::vip() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.vip)
  return vip_;
}
inline void GameRole::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.vip)
}

// -------------------------------------------------------------------

// RetLoginGameServer

// required .Cmd.LoginGameError error = 1;
inline bool RetLoginGameServer::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetLoginGameServer::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetLoginGameServer::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetLoginGameServer::clear_error() {
  error_ = 100;
  clear_has_error();
}
inline ::Cmd::LoginGameError RetLoginGameServer::error() const {
  // @@protoc_insertion_point(field_get:Cmd.RetLoginGameServer.error)
  return static_cast< ::Cmd::LoginGameError >(error_);
}
inline void RetLoginGameServer::set_error(::Cmd::LoginGameError value) {
  assert(::Cmd::LoginGameError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetLoginGameServer.error)
}

// required .Cmd.GameRole role = 2;
inline bool RetLoginGameServer::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetLoginGameServer::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetLoginGameServer::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetLoginGameServer::clear_role() {
  if (role_ != NULL) role_->::Cmd::GameRole::Clear();
  clear_has_role();
}
inline const ::Cmd::GameRole& RetLoginGameServer::role() const {
  // @@protoc_insertion_point(field_get:Cmd.RetLoginGameServer.role)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return role_ != NULL ? *role_ : *default_instance().role_;
#else
  return role_ != NULL ? *role_ : *default_instance_->role_;
#endif
}
inline ::Cmd::GameRole* RetLoginGameServer::mutable_role() {
  set_has_role();
  if (role_ == NULL) {
    role_ = new ::Cmd::GameRole;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.RetLoginGameServer.role)
  return role_;
}
inline ::Cmd::GameRole* RetLoginGameServer::release_role() {
  // @@protoc_insertion_point(field_release:Cmd.RetLoginGameServer.role)
  clear_has_role();
  ::Cmd::GameRole* temp = role_;
  role_ = NULL;
  return temp;
}
inline void RetLoginGameServer::set_allocated_role(::Cmd::GameRole* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetLoginGameServer.role)
}

// -------------------------------------------------------------------

// ReqCreateRole

// optional int32 sex = 1;
inline bool ReqCreateRole::has_sex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCreateRole::set_has_sex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCreateRole::clear_has_sex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCreateRole::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 ReqCreateRole::sex() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqCreateRole.sex)
  return sex_;
}
inline void ReqCreateRole::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqCreateRole.sex)
}

// optional int32 job = 2;
inline bool ReqCreateRole::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCreateRole::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCreateRole::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCreateRole::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 ReqCreateRole::job() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqCreateRole.job)
  return job_;
}
inline void ReqCreateRole::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqCreateRole.job)
}

// optional string name = 3;
inline bool ReqCreateRole::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqCreateRole::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqCreateRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqCreateRole::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ReqCreateRole::name() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqCreateRole.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqCreateRole::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqCreateRole.name)
}
inline void ReqCreateRole::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqCreateRole.name)
}
inline void ReqCreateRole::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqCreateRole.name)
}
inline ::std::string* ReqCreateRole::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqCreateRole.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqCreateRole::release_name() {
  // @@protoc_insertion_point(field_release:Cmd.ReqCreateRole.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqCreateRole::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqCreateRole.name)
}

// -------------------------------------------------------------------

// RetCreateRole

// optional .Cmd.CreateRoleError error = 1;
inline bool RetCreateRole::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetCreateRole::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetCreateRole::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetCreateRole::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::Cmd::CreateRoleError RetCreateRole::error() const {
  // @@protoc_insertion_point(field_get:Cmd.RetCreateRole.error)
  return static_cast< ::Cmd::CreateRoleError >(error_);
}
inline void RetCreateRole::set_error(::Cmd::CreateRoleError value) {
  assert(::Cmd::CreateRoleError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetCreateRole.error)
}

// optional .Cmd.GameRole role = 2;
inline bool RetCreateRole::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetCreateRole::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetCreateRole::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetCreateRole::clear_role() {
  if (role_ != NULL) role_->::Cmd::GameRole::Clear();
  clear_has_role();
}
inline const ::Cmd::GameRole& RetCreateRole::role() const {
  // @@protoc_insertion_point(field_get:Cmd.RetCreateRole.role)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return role_ != NULL ? *role_ : *default_instance().role_;
#else
  return role_ != NULL ? *role_ : *default_instance_->role_;
#endif
}
inline ::Cmd::GameRole* RetCreateRole::mutable_role() {
  set_has_role();
  if (role_ == NULL) {
    role_ = new ::Cmd::GameRole;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.RetCreateRole.role)
  return role_;
}
inline ::Cmd::GameRole* RetCreateRole::release_role() {
  // @@protoc_insertion_point(field_release:Cmd.RetCreateRole.role)
  clear_has_role();
  ::Cmd::GameRole* temp = role_;
  role_ = NULL;
  return temp;
}
inline void RetCreateRole::set_allocated_role(::Cmd::GameRole* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetCreateRole.role)
}

// -------------------------------------------------------------------

// RTMainUser

// optional int32 charID = 1;
inline bool RTMainUser::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTMainUser::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTMainUser::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTMainUser::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 RTMainUser::charid() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.charID)
  return charid_;
}
inline void RTMainUser::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.charID)
}

// optional int32 job = 2;
inline bool RTMainUser::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTMainUser::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTMainUser::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTMainUser::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 RTMainUser::job() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.job)
  return job_;
}
inline void RTMainUser::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.job)
}

// optional int32 sex = 3;
inline bool RTMainUser::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTMainUser::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTMainUser::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTMainUser::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 RTMainUser::sex() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.sex)
  return sex_;
}
inline void RTMainUser::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.sex)
}

// optional string name = 4;
inline bool RTMainUser::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RTMainUser::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RTMainUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RTMainUser::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RTMainUser::name() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTMainUser::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.name)
}
inline void RTMainUser::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.RTMainUser.name)
}
inline void RTMainUser::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.RTMainUser.name)
}
inline ::std::string* RTMainUser::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Cmd.RTMainUser.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RTMainUser::release_name() {
  // @@protoc_insertion_point(field_release:Cmd.RTMainUser.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTMainUser::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Cmd.RTMainUser.name)
}

// optional int32 vip = 5;
inline bool RTMainUser::has_vip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RTMainUser::set_has_vip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RTMainUser::clear_has_vip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RTMainUser::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 RTMainUser::vip() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.vip)
  return vip_;
}
inline void RTMainUser::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.vip)
}

// -------------------------------------------------------------------

// RetTimeLine

// optional int32 trun = 1;
inline bool RetTimeLine::has_trun() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetTimeLine::set_has_trun() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetTimeLine::clear_has_trun() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetTimeLine::clear_trun() {
  trun_ = 0;
  clear_has_trun();
}
inline ::google::protobuf::int32 RetTimeLine::trun() const {
  // @@protoc_insertion_point(field_get:Cmd.RetTimeLine.trun)
  return trun_;
}
inline void RetTimeLine::set_trun(::google::protobuf::int32 value) {
  set_has_trun();
  trun_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetTimeLine.trun)
}

// optional int32 leftSeconds = 2;
inline bool RetTimeLine::has_leftseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetTimeLine::set_has_leftseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetTimeLine::clear_has_leftseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetTimeLine::clear_leftseconds() {
  leftseconds_ = 0;
  clear_has_leftseconds();
}
inline ::google::protobuf::int32 RetTimeLine::leftseconds() const {
  // @@protoc_insertion_point(field_get:Cmd.RetTimeLine.leftSeconds)
  return leftseconds_;
}
inline void RetTimeLine::set_leftseconds(::google::protobuf::int32 value) {
  set_has_leftseconds();
  leftseconds_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetTimeLine.leftSeconds)
}

// optional int32 totalSeconds = 3;
inline bool RetTimeLine::has_totalseconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetTimeLine::set_has_totalseconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetTimeLine::clear_has_totalseconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetTimeLine::clear_totalseconds() {
  totalseconds_ = 0;
  clear_has_totalseconds();
}
inline ::google::protobuf::int32 RetTimeLine::totalseconds() const {
  // @@protoc_insertion_point(field_get:Cmd.RetTimeLine.totalSeconds)
  return totalseconds_;
}
inline void RetTimeLine::set_totalseconds(::google::protobuf::int32 value) {
  set_has_totalseconds();
  totalseconds_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetTimeLine.totalSeconds)
}

// -------------------------------------------------------------------

// ItemObject

// optional int32 dbID = 1;
inline bool ItemObject::has_dbid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemObject::set_has_dbid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemObject::clear_has_dbid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemObject::clear_dbid() {
  dbid_ = 0;
  clear_has_dbid();
}
inline ::google::protobuf::int32 ItemObject::dbid() const {
  // @@protoc_insertion_point(field_get:Cmd.ItemObject.dbID)
  return dbid_;
}
inline void ItemObject::set_dbid(::google::protobuf::int32 value) {
  set_has_dbid();
  dbid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ItemObject.dbID)
}

// optional int32 itemid = 2;
inline bool ItemObject::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemObject::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemObject::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemObject::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ItemObject::itemid() const {
  // @@protoc_insertion_point(field_get:Cmd.ItemObject.itemid)
  return itemid_;
}
inline void ItemObject::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ItemObject.itemid)
}

// optional int32 count = 3;
inline bool ItemObject::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemObject::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemObject::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemObject::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ItemObject::count() const {
  // @@protoc_insertion_point(field_get:Cmd.ItemObject.count)
  return count_;
}
inline void ItemObject::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ItemObject.count)
}

// optional .GameDefine.ObjectCellType cell = 4 [default = ObjectCellType_None];
inline bool ItemObject::has_cell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemObject::set_has_cell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemObject::clear_has_cell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemObject::clear_cell() {
  cell_ = 0;
  clear_has_cell();
}
inline ::GameDefine::ObjectCellType ItemObject::cell() const {
  // @@protoc_insertion_point(field_get:Cmd.ItemObject.cell)
  return static_cast< ::GameDefine::ObjectCellType >(cell_);
}
inline void ItemObject::set_cell(::GameDefine::ObjectCellType value) {
  assert(::GameDefine::ObjectCellType_IsValid(value));
  set_has_cell();
  cell_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ItemObject.cell)
}

// optional int32 position = 5;
inline bool ItemObject::has_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ItemObject::set_has_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ItemObject::clear_has_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ItemObject::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 ItemObject::position() const {
  // @@protoc_insertion_point(field_get:Cmd.ItemObject.position)
  return position_;
}
inline void ItemObject::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ItemObject.position)
}

// -------------------------------------------------------------------

// RetObjectAdd

// repeated .Cmd.ItemObject objects = 1;
inline int RetObjectAdd::objects_size() const {
  return objects_.size();
}
inline void RetObjectAdd::clear_objects() {
  objects_.Clear();
}
inline const ::Cmd::ItemObject& RetObjectAdd::objects(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.RetObjectAdd.objects)
  return objects_.Get(index);
}
inline ::Cmd::ItemObject* RetObjectAdd::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.RetObjectAdd.objects)
  return objects_.Mutable(index);
}
inline ::Cmd::ItemObject* RetObjectAdd::add_objects() {
  // @@protoc_insertion_point(field_add:Cmd.RetObjectAdd.objects)
  return objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >*
RetObjectAdd::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.RetObjectAdd.objects)
  return &objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >&
RetObjectAdd::objects() const {
  // @@protoc_insertion_point(field_list:Cmd.RetObjectAdd.objects)
  return objects_;
}

// -------------------------------------------------------------------

// RetObjectSync

// repeated .Cmd.ItemObject objects = 1;
inline int RetObjectSync::objects_size() const {
  return objects_.size();
}
inline void RetObjectSync::clear_objects() {
  objects_.Clear();
}
inline const ::Cmd::ItemObject& RetObjectSync::objects(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.RetObjectSync.objects)
  return objects_.Get(index);
}
inline ::Cmd::ItemObject* RetObjectSync::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.RetObjectSync.objects)
  return objects_.Mutable(index);
}
inline ::Cmd::ItemObject* RetObjectSync::add_objects() {
  // @@protoc_insertion_point(field_add:Cmd.RetObjectSync.objects)
  return objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >*
RetObjectSync::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.RetObjectSync.objects)
  return &objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ItemObject >&
RetObjectSync::objects() const {
  // @@protoc_insertion_point(field_list:Cmd.RetObjectSync.objects)
  return objects_;
}

// -------------------------------------------------------------------

// RetObjectDelete

// repeated int32 objects = 1;
inline int RetObjectDelete::objects_size() const {
  return objects_.size();
}
inline void RetObjectDelete::clear_objects() {
  objects_.Clear();
}
inline ::google::protobuf::int32 RetObjectDelete::objects(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.RetObjectDelete.objects)
  return objects_.Get(index);
}
inline void RetObjectDelete::set_objects(int index, ::google::protobuf::int32 value) {
  objects_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.RetObjectDelete.objects)
}
inline void RetObjectDelete::add_objects(::google::protobuf::int32 value) {
  objects_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.RetObjectDelete.objects)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RetObjectDelete::objects() const {
  // @@protoc_insertion_point(field_list:Cmd.RetObjectDelete.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RetObjectDelete::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.RetObjectDelete.objects)
  return &objects_;
}

// -------------------------------------------------------------------

// RetObjectMove

// optional int32 dbID = 1;
inline bool RetObjectMove::has_dbid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetObjectMove::set_has_dbid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetObjectMove::clear_has_dbid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetObjectMove::clear_dbid() {
  dbid_ = 0;
  clear_has_dbid();
}
inline ::google::protobuf::int32 RetObjectMove::dbid() const {
  // @@protoc_insertion_point(field_get:Cmd.RetObjectMove.dbID)
  return dbid_;
}
inline void RetObjectMove::set_dbid(::google::protobuf::int32 value) {
  set_has_dbid();
  dbid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetObjectMove.dbID)
}

// optional .GameDefine.ObjectCellType cell = 2 [default = ObjectCellType_None];
inline bool RetObjectMove::has_cell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetObjectMove::set_has_cell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetObjectMove::clear_has_cell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetObjectMove::clear_cell() {
  cell_ = 0;
  clear_has_cell();
}
inline ::GameDefine::ObjectCellType RetObjectMove::cell() const {
  // @@protoc_insertion_point(field_get:Cmd.RetObjectMove.cell)
  return static_cast< ::GameDefine::ObjectCellType >(cell_);
}
inline void RetObjectMove::set_cell(::GameDefine::ObjectCellType value) {
  assert(::GameDefine::ObjectCellType_IsValid(value));
  set_has_cell();
  cell_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetObjectMove.cell)
}

// optional int32 position = 3;
inline bool RetObjectMove::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetObjectMove::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetObjectMove::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetObjectMove::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 RetObjectMove::position() const {
  // @@protoc_insertion_point(field_get:Cmd.RetObjectMove.position)
  return position_;
}
inline void RetObjectMove::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetObjectMove.position)
}

// -------------------------------------------------------------------

// ReqUseObject

// optional int32 dbID = 1;
inline bool ReqUseObject::has_dbid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqUseObject::set_has_dbid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqUseObject::clear_has_dbid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqUseObject::clear_dbid() {
  dbid_ = 0;
  clear_has_dbid();
}
inline ::google::protobuf::int32 ReqUseObject::dbid() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqUseObject.dbID)
  return dbid_;
}
inline void ReqUseObject::set_dbid(::google::protobuf::int32 value) {
  set_has_dbid();
  dbid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqUseObject.dbID)
}

// optional int32 count = 2;
inline bool ReqUseObject::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqUseObject::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqUseObject::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqUseObject::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ReqUseObject::count() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqUseObject.count)
  return count_;
}
inline void ReqUseObject::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqUseObject.count)
}

// -------------------------------------------------------------------

// RetMessage

// optional .Cmd.MessageChannel channel = 1;
inline bool RetMessage::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetMessage::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetMessage::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetMessage::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::Cmd::MessageChannel RetMessage::channel() const {
  // @@protoc_insertion_point(field_get:Cmd.RetMessage.channel)
  return static_cast< ::Cmd::MessageChannel >(channel_);
}
inline void RetMessage::set_channel(::Cmd::MessageChannel value) {
  assert(::Cmd::MessageChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetMessage.channel)
}

// optional string sender = 2;
inline bool RetMessage::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetMessage::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetMessage::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetMessage::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sender();
}
inline const ::std::string& RetMessage::sender() const {
  // @@protoc_insertion_point(field_get:Cmd.RetMessage.sender)
  return sender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetMessage::set_sender(const ::std::string& value) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.RetMessage.sender)
}
inline void RetMessage::set_sender(const char* value) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.RetMessage.sender)
}
inline void RetMessage::set_sender(const char* value, size_t size) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.RetMessage.sender)
}
inline ::std::string* RetMessage::mutable_sender() {
  set_has_sender();
  // @@protoc_insertion_point(field_mutable:Cmd.RetMessage.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RetMessage::release_sender() {
  // @@protoc_insertion_point(field_release:Cmd.RetMessage.sender)
  clear_has_sender();
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetMessage::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetMessage.sender)
}

// optional string content = 3;
inline bool RetMessage::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetMessage::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetMessage::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& RetMessage::content() const {
  // @@protoc_insertion_point(field_get:Cmd.RetMessage.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetMessage::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.RetMessage.content)
}
inline void RetMessage::set_content(const char* value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.RetMessage.content)
}
inline void RetMessage::set_content(const char* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.RetMessage.content)
}
inline ::std::string* RetMessage::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:Cmd.RetMessage.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RetMessage::release_content() {
  // @@protoc_insertion_point(field_release:Cmd.RetMessage.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetMessage::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetMessage.content)
}

// optional int32 localTime = 4;
inline bool RetMessage::has_localtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetMessage::set_has_localtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetMessage::clear_has_localtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetMessage::clear_localtime() {
  localtime_ = 0;
  clear_has_localtime();
}
inline ::google::protobuf::int32 RetMessage::localtime() const {
  // @@protoc_insertion_point(field_get:Cmd.RetMessage.localTime)
  return localtime_;
}
inline void RetMessage::set_localtime(::google::protobuf::int32 value) {
  set_has_localtime();
  localtime_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetMessage.localTime)
}

// -------------------------------------------------------------------

// ReqChat

// optional .Cmd.MessageChannel channel = 1;
inline bool ReqChat::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChat::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChat::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChat::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::Cmd::MessageChannel ReqChat::channel() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqChat.channel)
  return static_cast< ::Cmd::MessageChannel >(channel_);
}
inline void ReqChat::set_channel(::Cmd::MessageChannel value) {
  assert(::Cmd::MessageChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqChat.channel)
}

// optional int32 roleID = 2;
inline bool ReqChat::has_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqChat::set_has_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqChat::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqChat::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 ReqChat::roleid() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqChat.roleID)
  return roleid_;
}
inline void ReqChat::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqChat.roleID)
}

// optional string from = 3;
inline bool ReqChat::has_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqChat::set_has_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqChat::clear_has_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqChat::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& ReqChat::from() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqChat.from)
  return from_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqChat::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqChat.from)
}
inline void ReqChat::set_from(const char* value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqChat.from)
}
inline void ReqChat::set_from(const char* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqChat.from)
}
inline ::std::string* ReqChat::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqChat.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqChat::release_from() {
  // @@protoc_insertion_point(field_release:Cmd.ReqChat.from)
  clear_has_from();
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqChat::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqChat.from)
}

// optional string to = 4;
inline bool ReqChat::has_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqChat::set_has_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqChat::clear_has_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqChat::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& ReqChat::to() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqChat.to)
  return to_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqChat::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqChat.to)
}
inline void ReqChat::set_to(const char* value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqChat.to)
}
inline void ReqChat::set_to(const char* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqChat.to)
}
inline ::std::string* ReqChat::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqChat.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqChat::release_to() {
  // @@protoc_insertion_point(field_release:Cmd.ReqChat.to)
  clear_has_to();
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqChat::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqChat.to)
}

// optional string content = 5;
inline bool ReqChat::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqChat::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqChat::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqChat::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ReqChat::content() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqChat.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqChat::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqChat.content)
}
inline void ReqChat::set_content(const char* value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqChat.content)
}
inline void ReqChat::set_content(const char* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqChat.content)
}
inline ::std::string* ReqChat::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqChat.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqChat::release_content() {
  // @@protoc_insertion_point(field_release:Cmd.ReqChat.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqChat::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqChat.content)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Cmd::AccountAction> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::AccountErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::LoginGameError> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::CreateRoleError> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::MessageSender> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::MessageChannel> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Command_2eproto__INCLUDED
