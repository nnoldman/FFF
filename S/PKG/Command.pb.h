// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Command.proto

#ifndef PROTOBUF_Command_2eproto__INCLUDED
#define PROTOBUF_Command_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace Cmd {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Command_2eproto();
void protobuf_AssignDesc_Command_2eproto();
void protobuf_ShutdownFile_Command_2eproto();

class GameRole;
class RTMainUser;
class ReqAccountOperation;
class ReqCreateRole;
class ReqLoginGameServer;
class RetAccountOperation;
class RetCreateRole;
class RetLoginGameServer;

enum AccountAction {
  AccountAction_None = 0,
  AccountAction_Create = 1,
  AccountAction_Rename = 2,
  AccountAction_Delete = 3,
  AccountAction_Login = 4
};
bool AccountAction_IsValid(int value);
const AccountAction AccountAction_MIN = AccountAction_None;
const AccountAction AccountAction_MAX = AccountAction_Login;
const int AccountAction_ARRAYSIZE = AccountAction_MAX + 1;

enum AccountErrorCode {
  AccountErrorCode_None = 0,
  AccountErrorCode_CreateSucessed = 1,
  AccountErrorCode_NameRepeated = 2,
  AccountErrorCode_UserCantFind = 3,
  AccountErrorCode_PasswordError = 4,
  AccountErrorCode_LoginSucessed = 5
};
bool AccountErrorCode_IsValid(int value);
const AccountErrorCode AccountErrorCode_MIN = AccountErrorCode_None;
const AccountErrorCode AccountErrorCode_MAX = AccountErrorCode_LoginSucessed;
const int AccountErrorCode_ARRAYSIZE = AccountErrorCode_MAX + 1;

enum LoginGameError {
  LoginGameSucess = 0,
  LoginGameOverdue = 1,
  LoginGameInvalid = 2
};
bool LoginGameError_IsValid(int value);
const LoginGameError LoginGameError_MIN = LoginGameSucess;
const LoginGameError LoginGameError_MAX = LoginGameInvalid;
const int LoginGameError_ARRAYSIZE = LoginGameError_MAX + 1;

enum CreateRoleError {
  CreateRoleSucess = 0,
  CreateRoleNameRepeated = 1
};
bool CreateRoleError_IsValid(int value);
const CreateRoleError CreateRoleError_MIN = CreateRoleSucess;
const CreateRoleError CreateRoleError_MAX = CreateRoleNameRepeated;
const int CreateRoleError_ARRAYSIZE = CreateRoleError_MAX + 1;

// ===================================================================

class ReqAccountOperation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqAccountOperation) */ {
 public:
  ReqAccountOperation();
  virtual ~ReqAccountOperation();

  ReqAccountOperation(const ReqAccountOperation& from);

  inline ReqAccountOperation& operator=(const ReqAccountOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqAccountOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqAccountOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqAccountOperation* other);

  // implements Message ----------------------------------------------

  inline ReqAccountOperation* New() const { return New(NULL); }

  ReqAccountOperation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqAccountOperation& from);
  void MergeFrom(const ReqAccountOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqAccountOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Cmd.AccountAction action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::Cmd::AccountAction action() const;
  void set_action(::Cmd::AccountAction value);

  // required string user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Cmd.ReqAccountOperation)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  int action_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqAccountOperation* default_instance_;
};
// -------------------------------------------------------------------

class RetAccountOperation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetAccountOperation) */ {
 public:
  RetAccountOperation();
  virtual ~RetAccountOperation();

  RetAccountOperation(const RetAccountOperation& from);

  inline RetAccountOperation& operator=(const RetAccountOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetAccountOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetAccountOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetAccountOperation* other);

  // implements Message ----------------------------------------------

  inline RetAccountOperation* New() const { return New(NULL); }

  RetAccountOperation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetAccountOperation& from);
  void MergeFrom(const RetAccountOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetAccountOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Cmd.AccountErrorCode error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Cmd::AccountErrorCode error() const;
  void set_error(::Cmd::AccountErrorCode value);

  // required int32 accountid = 2;
  bool has_accountid() const;
  void clear_accountid();
  static const int kAccountidFieldNumber = 2;
  ::google::protobuf::int32 accountid() const;
  void set_accountid(::google::protobuf::int32 value);

  // required int32 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // required string token = 4;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // repeated int32 late_serverids = 5;
  int late_serverids_size() const;
  void clear_late_serverids();
  static const int kLateServeridsFieldNumber = 5;
  ::google::protobuf::int32 late_serverids(int index) const;
  void set_late_serverids(int index, ::google::protobuf::int32 value);
  void add_late_serverids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      late_serverids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_late_serverids();

  // @@protoc_insertion_point(class_scope:Cmd.RetAccountOperation)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int error_;
  ::google::protobuf::int32 accountid_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > late_serverids_;
  ::google::protobuf::int32 time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetAccountOperation* default_instance_;
};
// -------------------------------------------------------------------

class ReqLoginGameServer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqLoginGameServer) */ {
 public:
  ReqLoginGameServer();
  virtual ~ReqLoginGameServer();

  ReqLoginGameServer(const ReqLoginGameServer& from);

  inline ReqLoginGameServer& operator=(const ReqLoginGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqLoginGameServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqLoginGameServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqLoginGameServer* other);

  // implements Message ----------------------------------------------

  inline ReqLoginGameServer* New() const { return New(NULL); }

  ReqLoginGameServer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqLoginGameServer& from);
  void MergeFrom(const ReqLoginGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqLoginGameServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 accountid = 1;
  bool has_accountid() const;
  void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  ::google::protobuf::int32 accountid() const;
  void set_accountid(::google::protobuf::int32 value);

  // required int32 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // required string token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Cmd.ReqLoginGameServer)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 accountid_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqLoginGameServer* default_instance_;
};
// -------------------------------------------------------------------

class GameRole : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.GameRole) */ {
 public:
  GameRole();
  virtual ~GameRole();

  GameRole(const GameRole& from);

  inline GameRole& operator=(const GameRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GameRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameRole* other);

  // implements Message ----------------------------------------------

  inline GameRole* New() const { return New(NULL); }

  GameRole* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameRole& from);
  void MergeFrom(const GameRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 sex = 4;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 4;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // optional int32 job = 5;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 5;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // optional int32 vip = 6;
  bool has_vip() const;
  void clear_vip();
  static const int kVipFieldNumber = 6;
  ::google::protobuf::int32 vip() const;
  void set_vip(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.GameRole)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_vip();
  inline void clear_has_vip();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 vip_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static GameRole* default_instance_;
};
// -------------------------------------------------------------------

class RetLoginGameServer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetLoginGameServer) */ {
 public:
  RetLoginGameServer();
  virtual ~RetLoginGameServer();

  RetLoginGameServer(const RetLoginGameServer& from);

  inline RetLoginGameServer& operator=(const RetLoginGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetLoginGameServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetLoginGameServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetLoginGameServer* other);

  // implements Message ----------------------------------------------

  inline RetLoginGameServer* New() const { return New(NULL); }

  RetLoginGameServer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetLoginGameServer& from);
  void MergeFrom(const RetLoginGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetLoginGameServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.LoginGameError error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Cmd::LoginGameError error() const;
  void set_error(::Cmd::LoginGameError value);

  // optional .Cmd.GameRole role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::Cmd::GameRole& role() const;
  ::Cmd::GameRole* mutable_role();
  ::Cmd::GameRole* release_role();
  void set_allocated_role(::Cmd::GameRole* role);

  // @@protoc_insertion_point(class_scope:Cmd.RetLoginGameServer)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Cmd::GameRole* role_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetLoginGameServer* default_instance_;
};
// -------------------------------------------------------------------

class ReqCreateRole : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.ReqCreateRole) */ {
 public:
  ReqCreateRole();
  virtual ~ReqCreateRole();

  ReqCreateRole(const ReqCreateRole& from);

  inline ReqCreateRole& operator=(const ReqCreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqCreateRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqCreateRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqCreateRole* other);

  // implements Message ----------------------------------------------

  inline ReqCreateRole* New() const { return New(NULL); }

  ReqCreateRole* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqCreateRole& from);
  void MergeFrom(const ReqCreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqCreateRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sex = 1;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 1;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // required int32 job = 2;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 2;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Cmd.ReqCreateRole)
 private:
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_name();
  inline void clear_has_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static ReqCreateRole* default_instance_;
};
// -------------------------------------------------------------------

class RetCreateRole : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RetCreateRole) */ {
 public:
  RetCreateRole();
  virtual ~RetCreateRole();

  RetCreateRole(const RetCreateRole& from);

  inline RetCreateRole& operator=(const RetCreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RetCreateRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RetCreateRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RetCreateRole* other);

  // implements Message ----------------------------------------------

  inline RetCreateRole* New() const { return New(NULL); }

  RetCreateRole* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RetCreateRole& from);
  void MergeFrom(const RetCreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetCreateRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Cmd.CreateRoleError error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Cmd::CreateRoleError error() const;
  void set_error(::Cmd::CreateRoleError value);

  // required .Cmd.GameRole role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::Cmd::GameRole& role() const;
  ::Cmd::GameRole* mutable_role();
  ::Cmd::GameRole* release_role();
  void set_allocated_role(::Cmd::GameRole* role);

  // @@protoc_insertion_point(class_scope:Cmd.RetCreateRole)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_role();
  inline void clear_has_role();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Cmd::GameRole* role_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RetCreateRole* default_instance_;
};
// -------------------------------------------------------------------

class RTMainUser : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Cmd.RTMainUser) */ {
 public:
  RTMainUser();
  virtual ~RTMainUser();

  RTMainUser(const RTMainUser& from);

  inline RTMainUser& operator=(const RTMainUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RTMainUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RTMainUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RTMainUser* other);

  // implements Message ----------------------------------------------

  inline RTMainUser* New() const { return New(NULL); }

  RTMainUser* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RTMainUser& from);
  void MergeFrom(const RTMainUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RTMainUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 charID = 1;
  bool has_charid() const;
  void clear_charid();
  static const int kCharIDFieldNumber = 1;
  ::google::protobuf::int32 charid() const;
  void set_charid(::google::protobuf::int32 value);

  // required int32 job = 2;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 2;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // required int32 sex = 3;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 3;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // required string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 vip = 5;
  bool has_vip() const;
  void clear_vip();
  static const int kVipFieldNumber = 5;
  ::google::protobuf::int32 vip() const;
  void set_vip(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.RTMainUser)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_vip();
  inline void clear_has_vip();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 vip_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Command_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Command_2eproto();
  #endif
  friend void protobuf_AssignDesc_Command_2eproto();
  friend void protobuf_ShutdownFile_Command_2eproto();

  void InitAsDefaultInstance();
  static RTMainUser* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ReqAccountOperation

// required .Cmd.AccountAction action = 1;
inline bool ReqAccountOperation::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAccountOperation::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAccountOperation::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAccountOperation::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::Cmd::AccountAction ReqAccountOperation::action() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqAccountOperation.action)
  return static_cast< ::Cmd::AccountAction >(action_);
}
inline void ReqAccountOperation::set_action(::Cmd::AccountAction value) {
  assert(::Cmd::AccountAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqAccountOperation.action)
}

// required string user = 2;
inline bool ReqAccountOperation::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAccountOperation::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAccountOperation::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAccountOperation::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ReqAccountOperation::user() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqAccountOperation.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqAccountOperation.user)
}
inline void ReqAccountOperation::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqAccountOperation.user)
}
inline void ReqAccountOperation::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqAccountOperation.user)
}
inline ::std::string* ReqAccountOperation::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqAccountOperation.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqAccountOperation::release_user() {
  // @@protoc_insertion_point(field_release:Cmd.ReqAccountOperation.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqAccountOperation.user)
}

// required string password = 3;
inline bool ReqAccountOperation::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAccountOperation::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAccountOperation::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAccountOperation::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& ReqAccountOperation::password() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqAccountOperation.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqAccountOperation.password)
}
inline void ReqAccountOperation::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqAccountOperation.password)
}
inline void ReqAccountOperation::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqAccountOperation.password)
}
inline ::std::string* ReqAccountOperation::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqAccountOperation.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqAccountOperation::release_password() {
  // @@protoc_insertion_point(field_release:Cmd.ReqAccountOperation.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqAccountOperation::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqAccountOperation.password)
}

// -------------------------------------------------------------------

// RetAccountOperation

// required .Cmd.AccountErrorCode error = 1;
inline bool RetAccountOperation::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetAccountOperation::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetAccountOperation::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetAccountOperation::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::Cmd::AccountErrorCode RetAccountOperation::error() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.error)
  return static_cast< ::Cmd::AccountErrorCode >(error_);
}
inline void RetAccountOperation::set_error(::Cmd::AccountErrorCode value) {
  assert(::Cmd::AccountErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.error)
}

// required int32 accountid = 2;
inline bool RetAccountOperation::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetAccountOperation::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetAccountOperation::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetAccountOperation::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 RetAccountOperation::accountid() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.accountid)
  return accountid_;
}
inline void RetAccountOperation::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.accountid)
}

// required int32 time = 3;
inline bool RetAccountOperation::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetAccountOperation::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetAccountOperation::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetAccountOperation::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 RetAccountOperation::time() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.time)
  return time_;
}
inline void RetAccountOperation::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.time)
}

// required string token = 4;
inline bool RetAccountOperation::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetAccountOperation::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetAccountOperation::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetAccountOperation::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& RetAccountOperation::token() const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetAccountOperation::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.token)
}
inline void RetAccountOperation::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.RetAccountOperation.token)
}
inline void RetAccountOperation::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.RetAccountOperation.token)
}
inline ::std::string* RetAccountOperation::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:Cmd.RetAccountOperation.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RetAccountOperation::release_token() {
  // @@protoc_insertion_point(field_release:Cmd.RetAccountOperation.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RetAccountOperation::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetAccountOperation.token)
}

// repeated int32 late_serverids = 5;
inline int RetAccountOperation::late_serverids_size() const {
  return late_serverids_.size();
}
inline void RetAccountOperation::clear_late_serverids() {
  late_serverids_.Clear();
}
inline ::google::protobuf::int32 RetAccountOperation::late_serverids(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.RetAccountOperation.late_serverids)
  return late_serverids_.Get(index);
}
inline void RetAccountOperation::set_late_serverids(int index, ::google::protobuf::int32 value) {
  late_serverids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.RetAccountOperation.late_serverids)
}
inline void RetAccountOperation::add_late_serverids(::google::protobuf::int32 value) {
  late_serverids_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.RetAccountOperation.late_serverids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RetAccountOperation::late_serverids() const {
  // @@protoc_insertion_point(field_list:Cmd.RetAccountOperation.late_serverids)
  return late_serverids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RetAccountOperation::mutable_late_serverids() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.RetAccountOperation.late_serverids)
  return &late_serverids_;
}

// -------------------------------------------------------------------

// ReqLoginGameServer

// required int32 accountid = 1;
inline bool ReqLoginGameServer::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLoginGameServer::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLoginGameServer::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLoginGameServer::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 ReqLoginGameServer::accountid() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqLoginGameServer.accountid)
  return accountid_;
}
inline void ReqLoginGameServer::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqLoginGameServer.accountid)
}

// required int32 time = 2;
inline bool ReqLoginGameServer::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLoginGameServer::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLoginGameServer::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLoginGameServer::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 ReqLoginGameServer::time() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqLoginGameServer.time)
  return time_;
}
inline void ReqLoginGameServer::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqLoginGameServer.time)
}

// required string token = 3;
inline bool ReqLoginGameServer::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLoginGameServer::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLoginGameServer::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLoginGameServer::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& ReqLoginGameServer::token() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqLoginGameServer.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLoginGameServer::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqLoginGameServer.token)
}
inline void ReqLoginGameServer::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqLoginGameServer.token)
}
inline void ReqLoginGameServer::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqLoginGameServer.token)
}
inline ::std::string* ReqLoginGameServer::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqLoginGameServer.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLoginGameServer::release_token() {
  // @@protoc_insertion_point(field_release:Cmd.ReqLoginGameServer.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLoginGameServer::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqLoginGameServer.token)
}

// -------------------------------------------------------------------

// GameRole

// optional int32 id = 1;
inline bool GameRole::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRole::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRole::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRole::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameRole::id() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.id)
  return id_;
}
inline void GameRole::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.id)
}

// optional int32 level = 2;
inline bool GameRole::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRole::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRole::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRole::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GameRole::level() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.level)
  return level_;
}
inline void GameRole::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.level)
}

// optional string name = 3;
inline bool GameRole::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameRole::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameRole::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GameRole::name() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRole::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.GameRole.name)
}
inline void GameRole::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.GameRole.name)
}
inline void GameRole::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.GameRole.name)
}
inline ::std::string* GameRole::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Cmd.GameRole.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameRole::release_name() {
  // @@protoc_insertion_point(field_release:Cmd.GameRole.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRole::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Cmd.GameRole.name)
}

// optional int32 sex = 4;
inline bool GameRole::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameRole::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameRole::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameRole::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 GameRole::sex() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.sex)
  return sex_;
}
inline void GameRole::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.sex)
}

// optional int32 job = 5;
inline bool GameRole::has_job() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameRole::set_has_job() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameRole::clear_has_job() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameRole::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 GameRole::job() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.job)
  return job_;
}
inline void GameRole::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.job)
}

// optional int32 vip = 6;
inline bool GameRole::has_vip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameRole::set_has_vip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameRole::clear_has_vip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameRole::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 GameRole::vip() const {
  // @@protoc_insertion_point(field_get:Cmd.GameRole.vip)
  return vip_;
}
inline void GameRole::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
  // @@protoc_insertion_point(field_set:Cmd.GameRole.vip)
}

// -------------------------------------------------------------------

// RetLoginGameServer

// optional .Cmd.LoginGameError error = 1;
inline bool RetLoginGameServer::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetLoginGameServer::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetLoginGameServer::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetLoginGameServer::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::Cmd::LoginGameError RetLoginGameServer::error() const {
  // @@protoc_insertion_point(field_get:Cmd.RetLoginGameServer.error)
  return static_cast< ::Cmd::LoginGameError >(error_);
}
inline void RetLoginGameServer::set_error(::Cmd::LoginGameError value) {
  assert(::Cmd::LoginGameError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetLoginGameServer.error)
}

// optional .Cmd.GameRole role = 2;
inline bool RetLoginGameServer::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetLoginGameServer::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetLoginGameServer::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetLoginGameServer::clear_role() {
  if (role_ != NULL) role_->::Cmd::GameRole::Clear();
  clear_has_role();
}
inline const ::Cmd::GameRole& RetLoginGameServer::role() const {
  // @@protoc_insertion_point(field_get:Cmd.RetLoginGameServer.role)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return role_ != NULL ? *role_ : *default_instance().role_;
#else
  return role_ != NULL ? *role_ : *default_instance_->role_;
#endif
}
inline ::Cmd::GameRole* RetLoginGameServer::mutable_role() {
  set_has_role();
  if (role_ == NULL) {
    role_ = new ::Cmd::GameRole;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.RetLoginGameServer.role)
  return role_;
}
inline ::Cmd::GameRole* RetLoginGameServer::release_role() {
  // @@protoc_insertion_point(field_release:Cmd.RetLoginGameServer.role)
  clear_has_role();
  ::Cmd::GameRole* temp = role_;
  role_ = NULL;
  return temp;
}
inline void RetLoginGameServer::set_allocated_role(::Cmd::GameRole* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetLoginGameServer.role)
}

// -------------------------------------------------------------------

// ReqCreateRole

// required int32 sex = 1;
inline bool ReqCreateRole::has_sex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCreateRole::set_has_sex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCreateRole::clear_has_sex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCreateRole::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 ReqCreateRole::sex() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqCreateRole.sex)
  return sex_;
}
inline void ReqCreateRole::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqCreateRole.sex)
}

// required int32 job = 2;
inline bool ReqCreateRole::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCreateRole::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCreateRole::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCreateRole::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 ReqCreateRole::job() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqCreateRole.job)
  return job_;
}
inline void ReqCreateRole::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ReqCreateRole.job)
}

// required string name = 3;
inline bool ReqCreateRole::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqCreateRole::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqCreateRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqCreateRole::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ReqCreateRole::name() const {
  // @@protoc_insertion_point(field_get:Cmd.ReqCreateRole.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqCreateRole::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.ReqCreateRole.name)
}
inline void ReqCreateRole::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.ReqCreateRole.name)
}
inline void ReqCreateRole::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.ReqCreateRole.name)
}
inline ::std::string* ReqCreateRole::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Cmd.ReqCreateRole.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqCreateRole::release_name() {
  // @@protoc_insertion_point(field_release:Cmd.ReqCreateRole.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqCreateRole::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Cmd.ReqCreateRole.name)
}

// -------------------------------------------------------------------

// RetCreateRole

// required .Cmd.CreateRoleError error = 1;
inline bool RetCreateRole::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetCreateRole::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetCreateRole::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetCreateRole::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::Cmd::CreateRoleError RetCreateRole::error() const {
  // @@protoc_insertion_point(field_get:Cmd.RetCreateRole.error)
  return static_cast< ::Cmd::CreateRoleError >(error_);
}
inline void RetCreateRole::set_error(::Cmd::CreateRoleError value) {
  assert(::Cmd::CreateRoleError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RetCreateRole.error)
}

// required .Cmd.GameRole role = 2;
inline bool RetCreateRole::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetCreateRole::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetCreateRole::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetCreateRole::clear_role() {
  if (role_ != NULL) role_->::Cmd::GameRole::Clear();
  clear_has_role();
}
inline const ::Cmd::GameRole& RetCreateRole::role() const {
  // @@protoc_insertion_point(field_get:Cmd.RetCreateRole.role)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return role_ != NULL ? *role_ : *default_instance().role_;
#else
  return role_ != NULL ? *role_ : *default_instance_->role_;
#endif
}
inline ::Cmd::GameRole* RetCreateRole::mutable_role() {
  set_has_role();
  if (role_ == NULL) {
    role_ = new ::Cmd::GameRole;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.RetCreateRole.role)
  return role_;
}
inline ::Cmd::GameRole* RetCreateRole::release_role() {
  // @@protoc_insertion_point(field_release:Cmd.RetCreateRole.role)
  clear_has_role();
  ::Cmd::GameRole* temp = role_;
  role_ = NULL;
  return temp;
}
inline void RetCreateRole::set_allocated_role(::Cmd::GameRole* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.RetCreateRole.role)
}

// -------------------------------------------------------------------

// RTMainUser

// required int32 charID = 1;
inline bool RTMainUser::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTMainUser::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTMainUser::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTMainUser::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 RTMainUser::charid() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.charID)
  return charid_;
}
inline void RTMainUser::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.charID)
}

// required int32 job = 2;
inline bool RTMainUser::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTMainUser::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTMainUser::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTMainUser::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 RTMainUser::job() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.job)
  return job_;
}
inline void RTMainUser::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.job)
}

// required int32 sex = 3;
inline bool RTMainUser::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTMainUser::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTMainUser::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTMainUser::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 RTMainUser::sex() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.sex)
  return sex_;
}
inline void RTMainUser::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.sex)
}

// required string name = 4;
inline bool RTMainUser::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RTMainUser::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RTMainUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RTMainUser::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RTMainUser::name() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTMainUser::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.name)
}
inline void RTMainUser::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cmd.RTMainUser.name)
}
inline void RTMainUser::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cmd.RTMainUser.name)
}
inline ::std::string* RTMainUser::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Cmd.RTMainUser.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RTMainUser::release_name() {
  // @@protoc_insertion_point(field_release:Cmd.RTMainUser.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTMainUser::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Cmd.RTMainUser.name)
}

// required int32 vip = 5;
inline bool RTMainUser::has_vip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RTMainUser::set_has_vip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RTMainUser::clear_has_vip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RTMainUser::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 RTMainUser::vip() const {
  // @@protoc_insertion_point(field_get:Cmd.RTMainUser.vip)
  return vip_;
}
inline void RTMainUser::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
  // @@protoc_insertion_point(field_set:Cmd.RTMainUser.vip)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Cmd::AccountAction> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::AccountErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::LoginGameError> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Cmd::CreateRoleError> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Command_2eproto__INCLUDED
